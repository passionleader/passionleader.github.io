---
# 속성은 대쉬 내부에 작성하세요

# 영문으로 같은 내용 작성 시 id 같아야 함
lng_pair: id_kakao_linux11
# 영문으로 작성하는 경우 영문제목
title: (Linux)DNS 서버 설치와 구성

# 저자 설정(생략 가능)
#author: initializer

# 카테고리와 태그 설정
category: 카카오클라우드스쿨
tags: [Linux, DNS]

# 섬네일 이미지
img: "https://bloximages.newyork1.vip.townnews.com/redandblack.com/content/tncms/assets/v3/editorial/4/59/45940eb2-5403-11e9-a843-db0e4491cc90/5ca13d8453042.image.jpg"

# 댓글 비활성화 여부
comments_disable: false

# 작성 날짜
date: 2022-07-22 13:18:51 +0900

# image_lazy_loader_posts = false 혹은 image_viewer_posts = false인 경우에만 사용하세요
#image_viewer_on: true
#image_lazy_loader_on: true

# 블로그내 검색 혹은 검색 엔진 검색에서 예외할건가
#on_site_search_exclude: true
#search_engine_exclude: true

# to disable this page, simply set published: false or delete this file
#published: false
---

<!-- outline-start -->

[카카오 클라우드 스쿨] 로컬 DNS 서버를 만들어 보자!

<!-- outline-end -->

## 네임 서버 종류!

* DNS 서비스를 제공하는 서버
  * 캐시 네임 서버
    * 자신이 직접 도메인을 관리하지 않음
    * 루트 도메인 서버(.com 서버 등)에게 질의한 최종 결과를 자신에 캐시에 저장한다
    * 최종 결과를 사용자에게 전달해 준다
    * 이후 동일 주소에 대한 쿼리가 또 있을 경우, 캐시 정보를 확인해서 전달해 줌
  * 마스터 네임 서버
    * test.com, test.co.kr과 같은 **도메인을 직접 관리**하는 서버임
    * zone 파일이라는 곳에 서브도메인 등을 작성
    * 외부에서 shopping.test.com과 같은 주소로 접속을 희망했을 경우, 서브도메인에 대한 주소를 알려주는 역할을 수행

<br>

* DNS 작동 과정
  * ![img_39](https://user-images.githubusercontent.com/104918800/183655176-676efba9-abae-45eb-b945-16ac4936d4c3.jpg)
  * 내부 DNS 서버?
    * shop.test.com, news.test.com 등 요청시 내부 도메인 주소를 알려줌
    * ex) maple.nexon.com, sa.nexon.com 등..
    * ![img_30](https://user-images.githubusercontent.com/104918800/183655173-30008602-0768-42c8-b56e-f02d6044f521.png)

<br>

> 프록시와 비슷하지만 다름
* ![img_40](https://user-images.githubusercontent.com/104918800/183655167-ff77cb47-def0-4a0c-8517-f01231a11bf0.jpg)


<br>
<hr>


## 도메인 서버 구성하기 (캐시 네임 서버로 작동)
* centOS7
  * DNS로 사용할 예정
  * 192.168.1.105
* centOS8
  * 일반 PC로 사용할 에정
  * 211.183.3.111
* 즉, centOS7은 캐시 네임 서버로 작동하고, 8.8.8.8로부터 도메인 네임을 전달받아서 건네주게 된다

<br>

**1 . centOS 8 측의 DNS 서버를 내 주소로 지정한다**
* ![img_25](https://user-images.githubusercontent.com/104918800/183655252-88553c9f-8b61-480d-a329-ab9ec07179aa.png)

<br>

* 내 네임서버 확인해 보기

```shell
[root@srv8 ~]# cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 192.168.1.105
```

<br>

* 이제 네임 서버 주소를 통해서는 접속할 수 없게 됨

```shell
[root@srv8 ~]# ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=128 time=45.8 ms

[root@srv8 ~]# ping www.google.com
ping: www.google.com: Name or service not known
```

<br>

**2 . bind-chroot 설치**

* 네임 서버를 구성하기 위해 다음 모듈을 설치한다
  * BIND: DNS를 구현한 소프트웨어
  * chroot: BIND가 작동되는 동안 /var/named/chroot 경로를 '/'(최상위 경로)로 지정 가능

```shell
yum -y install bind bind-chroot
```

<br>

**3 . DNS 서버 config**
* DNS 서버의 config 설정을 진행한다
  * vmware 네트워크 주소 안에 있는 모든 컴퓨터가 네임 서버를 사용할 수 있게 설정했다

```shell
[root@srv7 etc]# vi /etc/named.conf
---
        listen-on port 53 { any; };
        listen-on-v6 port 53 { none; };
        allow-query     { any; };

        dnssec-validation no;
---
systemctl restart named
```

* Listen-on
  * 해당 포트로 서비스를 제공할 수 있는 상태
  * 3 handshake 이후 세션이 성립(Established) 되면 데이터 요청시 언제든지 줄 수 있는 상태!
  * 이때의 포트, 접속 가능 범위를 지정한다
* allow-query
  * DNS에 대한 요청, 허용 범위
  * 서버 (test.com)에 대한 주소 요청시 주소를 알려줄 범위
  * 사설 구간에만 쓸 경우 IP를 써도 된다(192.168.1.0/24)
* 위 두개만 써져 있으면 Cache name server임
* 하단에 zone을 구성한다면 마스터 네임 서버로 작동시킬 수 있음(내부 DNS)

<br>

**4 . 구성 완료 후 클라이언트측에서 도메인 이름으로 접속해 보기**
* 성공적으로 접속되는 것을 확인할 수 있음

```shell
nslookup www.rapa.or.kr
dig www.rapa.or.kr
```

<br>

**5 . nslookup 사용해 보기**

* nslookup
  * 도메인 이름과 IP 주소를 확인할수 있는 툴
  * A타입: 도메인을 바로 알려 줌 (이 경우 .com 서버에서 해당 도메인을 등록해 둔 것)

* 참고
  * nslookup naver.com => 도메인 서버
  * nslookup www.naver.com => 홈페이지 서버
  * 둘의 주소는 다르다!

```shell
[root@srv7 etc]# nslookup nexon.com
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
Name:	nexon.com
Address: 52.78.145.30
Name:	nexon.com
Address: 52.78.153.209

[root@srv7 etc]# nslookup www.nexon.com
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
Name:	www.nexon.com
Address: 18.64.8.73
Name:	www.nexon.com
Address: 18.64.8.24
Name:	www.nexon.com
Address: 18.64.8.70
Name:	www.nexon.com
Address: 18.64.8.63
```

<br>
<hr>

## 로컬 DNS 서버에 내부 도메인 등록하기 (마스터 네임 서버로 작동)

* 실습 가정상황
  * 우리 회사에 있는 캐시네임 서버 192.168.1.105를 마스터 네임서버로 활용할 계획이다
  * 도메인 주소는 kkikki.com 이다.
  * 내부에 있는 211.183.3.111이 주소창에 www.kkikki.com 이라고 했을 때, 마스터네임서버에서 서비스하고 있는 웹 서비스를 동시에 제공할 수 있어야 한다

<br>

**1 . zone 파일 등록하기(내부 도메인 등록)**

```shell
[root@srv7 etc]# vi /etc/named.conf
---맨 하단--
zone "kkikki.com" IN {
        type master;
        file "kkikki.com.db";
        allow-update { none; };
        };
```

* ![img_31](https://user-images.githubusercontent.com/104918800/183655404-5beb2c2a-ded7-45dd-9628-b866fe84d364.png)
* ZONE: 자체적으로 도메인을 사용하고 있는 경우 구성해야 하는 부분임(의무)
  * 이 파일을 구성하기 전 DNS 서버의 공인 IP를 도메인 서버 (가비아 등 .com 서버)에 등록해야 함
  * gildong.com: 도메인 이름
  * IN: internet-class (인 아웃이 아님)
  * type:master: 마스터 서버이다
  * file: kikki.com에 DB에 저장되어 있다
  * update: 슬레이브 DNS 서버에 업데이터(동기화) 해 주겠다
* 여러 개의 Zone을 구성할 수 있다
* zone-file은   "/var/named" 에 구성되어 있다

<br>

* 오타가 없는지 확인(무반응이면 오타 없는 것)

```shell
[root@srv7 etc]# named-checkconf

```

* Master의 존 파일 업데이트 완료

<br>

**2 . 일반적인 Zone 파일 작성하기**

* 마스터에 존 파일을 업데이트 했다면, 슬레이브에 업데이트를 실행여부를 지정 가능
  * (마스터: 주 서버. 슬레이브: 동기화되는 부 서버)
  * www.kkikki.com -> 내 아이피(105)의 httpd로 접속되게끔 함
  * hr.kkikki.com -> 다른 학우(101)의 httpd로 접속되게끔 함
  * shop.kkikki.com -> 강사님(199)의 httpd로 접속되게끔 함

```shell
[root@srv7 named]# cd /var/named
[root@srv7 named]# touch kkikki.com.db
[root@srv7 named]# vi kkikki.com.db
---
$TTL            3H
@       SOA     @       root.   ( 2 1D 1H 1W 1H )
        IN      NS      @
        IN      A       192.168.1.105


www     IN      A       192.168.1.105

shop    IN      A       192.168.1.199
hr      IN      A       192.168.1.101
```

* TTL 3H: IP를 캐시에 세 시간동안만 저장한다 (캐시 - hosts 파일 - DNS 서버)
* @: 도메인 이름 자체를 의미(kkikki.com)
* root: kkikki.com을 관리하는 최상위 서버
* SOA: 권한 시작
  * 2: Serial
    * 자신이 slave 인 경우, master의 serial 보다 높다면, master에게 업데이트된 정보를 요청한다
    * 일반적으로 날짜, 시간 등을 이용해서 작성한다
  * 1D: 2차 네임서버가 1차 네임서버에 접속하는 시간
    * slave가 실시간으로 mater에게 접속할 필요는 없음
    * 하루에 한번만 master에 접속해 serial을 비교하겠다는 의미
  * 1H: 접속 실패 시, 재접속하는 간격
    * 1D 접속 실패시, 1H 간격으로 다시 시도한다
  * 1W: 마스터가 죽었을 때의 처리
    * 1차 네임 서버에 데이터가 없다면, 1주일 뒤 삭제한다
    * 마스터가 죽어도 1주일 동안은 계속 서비스를 하겠다고 설정
  * 1H: TTL
    * 만약 마스터로부터 정보를 쿼리한 뒤 받았다면 1시간 동안 보관한다
    * 상단에 @ TTL 3H가 우선시되며, 없을 경우 이 시간이 TTL임
    * 따라서 캐시에 저장하는 시간은 3H

<br>

* www, shop, hr 등 서브 도메인
  * IN: 인터넷
  * NS: name server
  * A: 도메인에 대한 IP 정보
  * CNAME: 도메인에 대한 별칭, 주로 한 개의 도메인에 여러 정보를 연결해서 사용할 때 사용
    * ex) IN NS @ : 내가 kkikki.com의 네임 서버이다(kkikki.com)
    * ex) www IN A 192.169.1.199: kkikki.com의 네임 서버 주소는 이와 같다
    * ex) shop IN A 192.169.1.200: kkikki.com의 하위 네임 서버 주소는 이와 같다


<br>

**3 . 로드밸런서를 구성할 경우의 zone 파일 구성하기**

```shell
www     IN      CNAME     websrv.kkikki.com
websrv  100     IN        A                 1.1.1.1 (사실상
websrv  200     IN        A                 1.1.1.3  로드밸런서의
websrv  300     IN        A                 1.1.1.4  주소)
```


* 사용자가 서버에 대해 요청을 했을 때, 처음 들어오는 사용자에 대해 각각 다르게 (1.1.1.1, 1.1.1.3.. )보내겠다
  * 100, 200, 300은 그냥 순서 정도에 불과함
* 여담
  * anycast 라는 방법을 사용하면, 동일 주소에 대하여 물리 서버를 두대 이상 구성하고, 가까운 거리에 있는 사람들은 자신과 가까운 서버로 접속하게 된다
  * 제주도민들은 가까운 사람은 제주 데이터 센터로 우선 연결되게 할 수 있는 것
  * IPv6에서는 broadcast라는 개념이 사라졌다. 이를 해결하기 위한 용도로 anycast를 사용하기도 함



<br>

**4 . ifconfig DNS 설정**
* 서버측에서, 자신의 도메인 (kkikki.com)에 접속하기 위함
  * DNS1=127.0.0.1 (로컬) 을 추가한다
  * 로컬에 없는 경우 DNS2(8.8.8.8)에서 쿼리한다

```shell
[root@srv7 named]# vi /etc/sysconfig/network-scripts/ifcfg-eth0
---
TYPE=Ethernet
BOOTPROTO=none
NAME=eth0
DEVICE=eth0
ONBOOT=yes
DNS1=127.0.0.1
DNS2=8.8.8.8
IPADDR=192.168.1.105
PREFIX=24
GATEWAY=192.168.1.1
```

<br>

**5 . 서비스 재시작**

```shell
[root@srv7 named]# systemctl restart named
[root@srv7 named]# systemctl restart network
[root@srv7 named]# systemctl restart httpd
```

<br>

**6 . 결과**

* 이제 클라이언트측에서 접속해 보자
  * var/named/kkikki.com.db 파일에 다른 서버를 클라이언트에 알려 주었으므로, 다음을 확인할 수 있음
    * 강사님 페이지(shop.kkikki.com)
    * ![img_26](https://user-images.githubusercontent.com/104918800/183655408-f8fd76c0-92a2-4572-bdbb-8c60d52b624d.png)
    * 내 페이지(www.kkikki.com)
    * ![img_27](https://user-images.githubusercontent.com/104918800/183655410-40d00525-bf17-4fc8-bfd5-45028bffae9f.png)
    * 다른 학우의 페이지(hr.kkikki.com)
    * ![img_28](https://user-images.githubusercontent.com/104918800/183655397-02527040-0cb9-4af3-b464-4888c6a15361.png)

<br>
<hr>

## DNS + Proxy를 같이 구성한다면?
* 프록시?
  * Web proxy는 웹 서버의 내용을 캐시에 담고, 이를 클라이언트에 전달한다
  * 이후 동일 사이트 접속 시도시 캐시에 있는 내용을 LAN에서 전달하므로, 속도가 빠르다

<br>

* 다음과 같이 구성해 볼 수 있겠다(DNS + 프록시)
  * ![img_41](https://user-images.githubusercontent.com/104918800/183655507-8fcd5f72-4041-4c8e-8ac0-62b0871bed10.jpg)
  * 서버 내부의 DNS는 내부에서 밖으로 나갈 때 캐시 네임 서버로 작동하고
  * 외부에서 내부로 접속할 떄에는 마스터 네임 서버로 작동하낟
  * proxy를 두어 외부로 접속할 때 속도를 올릴 수 있다(DNS와 별개)

<br>
<hr>

## DNS 총 정리 노트
* 이제 이 그림이 이해가 될 것이다
* ![img_43](https://user-images.githubusercontent.com/104918800/183655496-0b161e10-b0e0-425e-8f7f-951adf4b814b.jpg)
